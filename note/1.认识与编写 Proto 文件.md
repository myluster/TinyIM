# 认识 Ptoto 文件
## 什么是 Protobuf，什么是 Proto?
**Protobuf (Google Protocol Buffers)** 是由谷歌开发的一套完整的**序列化框架**（包括编译器 `protoc` 和**各语言的运行时库**）。它的核心作用是提供一套机制，**将复杂的内存对象高效地转换为二进制数据**，反之亦然。

**Proto (`.proto` 文件)** 是 Protobuf 使用的 **IDL (Interface Definition Language，接口定义语言)**。
- 它是我们定义的**“契约”**。
- 它独立于具体的编程语言（C++、Java、Python 等）。
- 它的作用是描述数据结构和服务接口。

## 为什么需要 Proto 文件
Proto 属于OSI 七层系统中的**表示层**（TCP/IP 体系中属于应用层），明确的功能为**处理两个通信系统中交换信息的表示方式**，具体负责：
- **数据格式变换**
- **数据加密解密**
- **数据压缩与恢复**

在我们的微服务工程中，具体是这样的问题：
- **多语言异构**：不同服务由不同语言实现（例如：认证服务用 `Node.js`，网关用 `C++`）。
- **内存布局差异**：不同语言、甚至同语言不同编译器，其**内存布局完全不同**（涉及字节序、内存对齐等）。
- 如果在网络中直接传输 C++ 的内存数据给 Node.js，对方完全**无法识别**，会导致解析错误或崩溃。

Proto 的解决方案是：
- **契约化 (IDL)**：`.proto` 文件作为通用的**“契约”**。无论你是 C++ 还是 JS，只要拿到了这份契约，就能通过编译器生成各自语言的代码，完美地读懂对方发来的数据。
- **序列化**：通过各语言的 Proto 库，把特定的内存对象变成通用的 Proto **二进制字节流**。
- **反序列化**：接收端使用 Proto 库，把二进制字节流**还原成对应语言的内存对象**。


> [!NOTE] 为什么不使用 JSON?
> 虽然 JSON 通过通用文本（UTF-8）也能解决跨语言通信问题，且具备极佳的可读性，但在 **IM（即时通讯）** 等高性能场景下，Protobuf 具有决定性优势：
> **性能差距**：
> - **体积**：Protobuf 是紧凑的**二进制**格式，体积通常是 JSON 的 1/3，在移动端网络下更省流量、传输更快。
> - **速度**：Protobuf 的解析（反序列化）速度比 JSON 快**5-10 倍**，因为 JSON 需要进行复杂的字符串扫描，而 Protobuf 主要是**简单的位移操作**。
> 
> **契约精神 (Contract)**：
> - **JSON** 通常是“弱契约”，字段拼写错误往往要在**运行时**才能发现。
> - **Protobuf** 是“强契约”，`.proto` 文件强制规范了数据结构，若字段不匹配，**编译时**就会报错，大大降低了协作风险。
> 
> **总结**：我们牺牲了可读性，换取了**传输性能**和**类型安全**。
# 编写Proto 文件
## 明确使用范围
既然 Proto 是明确交换信息的格式，那么它**在会出现信息流动的地方使用**，我们首先需要列举在本项目中所需要信息流动的地方：
- 客户端 (Qt/Web) $\longleftrightarrow$ 接入网关 (Gateway)
- 接入网关 (Gateway) $\longleftrightarrow$ 后端微服务 (Auth/Chat)
- 后端微服务(Auth/Chat) $\longleftrightarrow$ 数据库（MySQL/Redis）
- 客户端（Qt）$\longleftrightarrow$ 数据库（SQLite）

因为与数据库之间的连接会通过专门的库进行，其本身就内置了协议的翻译器所以不需要使用 proto 进行连接。

> - **两端都是我们写的**：**我们要写 Proto** 来规定怎么交流。
> - **一端是现成的第三方软件**：**遵守对方的规则**，使用对方提供的驱动，不需要我们定义协议。

所以我们可以将通信需求拆解成三个具体的 Proto 文件：
- **`gateway.proto`**：负责定义 WebSocket 上的**通用数据包结构**和**消息类型枚举**。
- **`auth.proto`**：负责定义**登录、注册**相关的 RPC 接口和数据结构。
- **`chat.proto`**：负责定义**消息内容**、**存储**相关的 RPC 接口和数据结构。

## Proto 文件格式
Proto 文件的语法类似 C++/Java，但它不描述逻辑，只描述**结构**。一个标准的 `.proto` 文件通常由以下几个部分组成：

**头部声明 (Header)**
每个 Proto 文件都必须以这两个声明开头：
- **版本声明**：`syntax = "proto3";`
    - 指定使用 Proto3 语法（目前的主流版本，比 Proto2 更简化）。
- **包名声明**：`package api.v1;`
    - 类似于 C++ 的 `namespace`。防止不同项目之间的命名冲突。

**消息定义 (Message)**
`message` 是 Proto 中最基本的单元，用于定义数据结构。
```Protocol
message UserInfo {
  string username = 1;  // 字符串类型
  int32 age = 2;        // 32位整型
  bool is_online = 3;   // 布尔值
}
```

**服务定义 (Service)**
`service` 用于定义 RPC 方法集合。gRPC 插件会根据它生成服务端接口基类和客户端存根（Stub）。

```Protocol
service AuthService {
  rpc 方法名 (请求参数类型) returns (返回参数类型)
}
```

### 关键语法详解
#### 字段编号 (Tags) 
在 `string username = 1;` 中，这个 **`= 1` 不是赋值**，而是**字段的唯一编号 (Tag)**。
- **原理**：在二进制传输中，为了节省空间，Proto **不会传输变量名**（如 "username"），只会传输这个编号 `1`。
- **规则**：
    - 编号 **1-15** 占用 1 个字节（最高频使用的字段用这个范围）。
    - 编号 **16-2047** 占用 2 个字节。
    - **一旦定义并上线，绝对不能修改编号**，否则会导致新旧版本无法兼容。

#### 数据类型映射

|**Proto 类型**|**C++ 类型**|**说明**|
|---|---|---|
|`double` / `float`|`double` / `float`|浮点数|
|`int32` / `int64`|`int32_t` / `int64_t`|有符号整型|
|`uint32` / `uint64`|`uint32_t` / `uint64_t`|无符号整型|
|`bool`|`bool`|布尔值|
|`string`|`std::string`|处理 UTF-8 文本|
|`bytes`|`std::string`|处理任意二进制数据（如图片数据的 raw bytes）|

#### 特殊修饰符
- **`repeated`** (数组)：
- **`enum`** (枚举)：
- **`oneof`** (联合体)：

## proto 文件实现
为了起到逐步搭建的作用，先以传输的信息只有文本为前提进行文件设计
### `gateway.proto`
```protocol
syntax = "proto3";

package api.v1;

// 引入 chat.proto,这行代码表示 gateway 依赖于 chat 的定义。
import "api/v1/chat.proto"; 

// 消息类型枚举
// 作用：告诉接收方（网关或客户端），这个包到底是干什么的
enum MessageType {
  UNKNOWN = 0;           // 默认值，防止未初始化导致的误判
  
  // --- 系统级指令 ---
  HEARTBEAT_PING = 1;    // 客户端发出的心跳 "还在吗？"
  HEARTBEAT_PONG = 2;    // 服务端回复的心跳 "我还在"
  
  // --- 业务级指令 ---
  CHAT_SEND = 10;        // 客户端 -> 服务端：发送消息请求
  CHAT_PUSH = 11;        // 服务端 -> 客户端：推送新消息
  CHAT_ACK  = 12;        // 服务端 -> 客户端：确认消息已收到
}

// 网关消息 (The Envelope)
// 这是 WebSocket 上传输的唯一数据结构
// 所有的具体业务数据（聊天、心跳）都装在这个“信封”里
message GatewayMessage {
  MessageType type = 1;     // 消息类型：拆包员第一眼看这个
  int64 request_id = 2;     // 请求ID：用于 客户端请求 <-> 服务端响应 的匹配

  // oneof: 联合体，同一时刻只能存在其中一种数据，要么插 "错误信息"，要么插 "聊天数据"
  oneof payload {
    string error = 3;             // 如果出错，这里填错误原因
    bytes binary_data = 4;        // 预留：通用二进制数据
       
    // 下面这个 ChatPacket 定义在 chat.proto 中
    // 当 type 是 CHAT_SEND 或 CHAT_PUSH 时，数据放在这里
    ChatPacket chat_data = 5;     
  }
}
```

**细节把握：**
-  `import "api/v1/chat.proto";`：这体现了**模块化**思想。网关协议不需要知道“聊天包”里具体有什么（是文字还是图片），它只需要引用聊天的定义即可。
- `UNKNOWN = 0;`：在 Protobuf 中，数字类型的默认值是 0。如果您忘记给 `type` 赋值，它就会默认为 `UNKNOWN`。如果我们把 `HEARTBEAT_PING` 设为 0，那么一个**未初始化的空包**就会被误认为是心跳包，这会引发严重的逻辑 Bug。
- `oneof payload`：如果未来加入“文件传输”的功能，只需在 `oneof` 里加一行 `FilePacket file_data = 6;`，完全不破坏现有结构。

### `chat.proto`
```Protocol
syntax = "proto3";

package api.v1;

// 定义聊天服务 (Service)
service ChatService {
  // 接口 1: 保存/发送消息
  // 网关收到消息后，调用此接口将消息持久化到 MySQL
  rpc SaveMessage (ChatPacket) returns (SaveMessageRes);
  
  // 接口 2: 拉取历史消息
  // 客户端登录或打开聊天窗口时，调用此接口获取之前的聊天记录
  rpc GetHistory (GetHistoryReq) returns (GetHistoryRes);
}

// --- 数据结构定义 (Message) ---

// 聊天消息包 (核心结构)
// 这个结构会被 gateway.proto 中的 GatewayMessage 引用
message ChatPacket {
  int64 msg_id = 1;       // 消息ID (通常由服务端生成，如 Snowflake 算法)
  int64 from_user_id = 2; // 发送者 ID
  int64 to_user_id = 3;   // 接收者 ID
  int64 timestamp = 4;    // 发送时间戳
  
  string content = 5;     // 消息内容 (当前仅支持纯文本)
}

// 保存消息的响应
message SaveMessageRes {
  bool success = 1;       // 是否保存成功
  int64 msg_id = 2;       // 返回生成的 msg_id 给网关/客户端
  string error_msg = 3;   // 错误信息
}

// 拉取历史记录请求
message GetHistoryReq {
  int64 user_id = 1;      // 谁在拉取？
  int64 peer_id = 2;      // 拉取和谁的聊天记录？
  int64 last_msg_id = 3;  // 游标 (Cursor): 上一次拉取到的最后一条 ID (用于分页)
  int32 limit = 4;        // 这次想拉多少条 (例如 20 条)
}

// 拉取历史记录响应
message GetHistoryRes {
  // 返回一组消息列表
  repeated ChatPacket messages = 1; 
}
```

**细节把握：**
- **`service` vs `message`**：
    - **`message`** 定义的是“名词”（数据长什么样），如 `ChatPacket`。
    - **`service`** 定义的是“动词”（能做什么操作），如 `SaveMessage`。在微服务架构中，`service` 定义了模块间的 API 边界。
- **`repeated` 关键字**：相当于 C++ 的 `std::vector<ChatPacket>` 。在 `GetHistoryRes` 中，我们必须使用 `repeated`，因为历史记录往往是一组数据。
- **游标分页 (`last_msg_id`)**：在获取历史记录时，我们**尽量避免**使用 `page_number` (第几页) 的方式，因为新消息不断进来会导致页码偏移。所以使用“上一条消息的 ID”作为游标。

### `auth.proto`
```Protocol
syntax = "proto3";

package api.v1;

// 定义认证服务 (Service)
// 职责：处理所有与“我是谁”有关的请求
service AuthService {
  // 接口 1: 登录
  // 输入账号密码，如果正确，返回一个 Token (通行证)
  rpc Login (LoginReq) returns (LoginRes);

  // 接口 2: 注册
  // 创建新账号
  rpc Register (RegisterReq) returns (RegisterRes);
  
  // 接口 3: 校验 Token (这是给网关用的内部接口)
  // 网关收到 WebSocket 连接请求时，调用此接口检查 Token 是否合法
  rpc VerifyToken (VerifyTokenReq) returns (VerifyTokenRes);
}

// --- 数据结构定义 (Message) ---

// 登录请求
message LoginReq {
  string username = 1; 
  string password = 2; // 注意：实际传输建议用 HTTPS 加密，或者传输 Hash 后的值
}

// 登录响应
message LoginRes {
  bool success = 1;
  int64 user_id = 2;   // 用户唯一 ID (后续聊天全靠这个 ID 认人)
  string token = 3;    // JWT 或 SessionID (核心通行证)
  string error_msg = 4;
}

// 注册请求 (保持最简，仅需用户名密码)
message RegisterReq {
  string username = 1;
  string password = 2;
  // string email = 3; // 可选扩展
}

message RegisterRes {
  bool success = 1;
  int64 user_id = 2;
  string error_msg = 3;
}

// Token 校验请求
message VerifyTokenReq {
  string token = 1;
}

// Token 校验响应
message VerifyTokenRes {
  bool valid = 1;      // Token 是否有效
  int64 user_id = 2;   // 如果有效，告诉网关这个 Token 属于哪个 UserID
}
```
**细节把握：**
- **Token 的作用**：
    - 用户登录成功后，服务端不会一直保存用户的账号密码，而是发一个 **Token (令牌)** 给客户端。
    - 以后客户端发消息、拉历史记录，只需要带上 Token 即可，不需要每次都传密码。
- **User ID 是核心纽带**：
    - `auth.proto` 产出 User ID。
    - `chat.proto` 消费 User ID (作为 `from_user_id` 和 `to_user_id`)。
    - 两个服务通过这个 ID 进行逻辑关联，但物理上是解耦的。